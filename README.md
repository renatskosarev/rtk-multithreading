# rtk-multithreading

Аналог утилиты hashcat, подбирает исходное число по его длине, алгоритму шифрования и хэшу

! Работает только с числами

## Nota bene
Для поиска исходного числа берется промежуток всех возможных чисел, исходя из заданной длины, и распределяется для обработки между ядрами (потоками)

**Результат зависит от самого числа и от того, как были скоординированы промежутки для обработки между потоками:**

Для числа 75000 и 4 ядер результат будет найден очень быстро, ведь один из потоков будет обрабатывать промежуток [75000, 100000), то есть обнаружит нужное число на первой же итерации  
Если число ядер увеличить до 5, то время исполнения (внезапно) только увеличится — поток будет вычислять [60000, 80000), обнаружит нужное число позже

Но в среднем случае *большее количество потоков* все же даст *большую эффективность*


## Запуск

1. ```mvn package```
2. ```java -jar target/hashcat.jar <params>```

## Параметры

| Флаг | Описание                   | Пример                           |
|------|----------------------------|----------------------------------|
| -a   | Алгоритм шифрования        | MD5                              |
| -h   | Значение контрольной суммы | 827ccb0eea8a706c4c34a16891f84e7b |
| -l   | Длина исходного числа      | 5                                |

## Тесты

! Протестировано на машине с 4 ядрами

| Параметры                                                 | Результат             | Описание                                                                                                                                                                                            |
|-----------------------------------------------------------|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                                           | Incorrect parameters. | Параметры не переданы                                                                                                                                                                               |
| -a MD5 -h 827ccb0eea8a706c4c34a16891f84e7b -l 5           | 12345 (732ms)         | Корректный результат                                                                                                                                                                                |
| -a SHA-1 -h bb654c1aac8887ea1c0e0fa77db034b9ef7d5aa2 -l 5 | 75000 (47ms)          | Задача была разделена на четыре потока (кол-во ядер), один из которых искал числа в промежутке [75000, 99999]. Первым делом он обработал 75000, поэтому результат был найден за малое время (47 мс) |
| -a SHA-1 -h a045b7efa463c6ed195c644163f4168952fbd34a -l 5 | 99999 (1251ms)        | Один из потоков обрабатывал промежуток [75000, 99999]. Время выполнения значительно выше, чем в предыдущем тесте                                                                                    |

Цель двух последних тестов — показать, что время зависит как от количества ядер, так и от самого заданного числа :)

## Тесты на кол-во ядер (потоков)

Протестировано на числе 75000 (27099b1bb4f5d2f647df1faef21a5d9a) и алгоритме шифрования MD5:
```-a MD5 -h 27099b1bb4f5d2f647df1faef21a5d9a -l 5```

| Число ядер | Время (в миллисекундах) |
|------------|-------------------------|
| 1          | 1631                    |
| 2          | 895                     |
| 3          | 543                     |
| 4          | 80                      |
